<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>app.dti.proto.Utils API documentation</title>
<meta name="description" content="This software project was created in 2023 by the U.S. Federal government.
See INTENT.md for information about what that means. See CONTRIBUTORS.md
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>app.dti.proto.Utils</code></h1>
</header>
<section id="section-intro">
<p>This software project was created in 2023 by the U.S. Federal government.
See INTENT.md for information about what that means. See CONTRIBUTORS.md and
LICENSE.md for licensing, copyright, and attribution information.</p>
<p>Copyright 2023 U.S. Federal Government (in countries where recognized)
Copyright 2023 Michael Todd and Gilbert Peterson</p>
<p>Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This software project was created in 2023 by the U.S. Federal government.
See INTENT.md for information about what that means. See CONTRIBUTORS.md and
LICENSE.md for licensing, copyright, and attribution information.

Copyright 2023 U.S. Federal Government (in countries where recognized)
Copyright 2023 Michael Todd and Gilbert Peterson

Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
&#34;&#34;&#34;
import time, os
import json, csv, shutil
import numpy as np
import itertools, time
from collections import abc
from rich.console import Console
from rich.panel import Panel
import pandas as pd
import pathlib
import streamlit as st
from sklearn.metrics import (
    precision_recall_curve,
)
from sklearn.metrics import RocCurveDisplay as rcd
import matplotlib.pyplot as plt

class Timer:
    def __enter__(self):
        self.start = time.perf_counter()
        return self

    def __exit__(self, *args):
        self.end = time.perf_counter()
        self.interval = self.end - self.start

def nested_dict_iter(nested: dict) -&gt; dict:
    for key, value in nested.items():
        if isinstance(value, abc.Mapping):
            for inner_key, inner_value in nested_dict_iter(value):
                yield inner_key, inner_value
        else:
            yield key, value


def flatten_extend(matrix):
    flat_list = []
    for row in matrix:
        if isinstance(row, list):
            flat_list.extend(row)
        else:
            flat_list.append(row)
    return flat_list


def file_type_detector(file_path):
    # Check the file extension first
    if file_path.endswith(&#39;.json&#39;):
        return &#39;json&#39;
    elif file_path.endswith(&#39;.csv&#39;):
        return &#39;csv&#39;
    else:
        # If the extension is not definitive, check the content
        try:
            with open(file_path, &#39;r&#39;) as file:
                # Try parsing as JSON
                json.load(file)
                return &#39;json&#39;
        except (json.JSONDecodeError, UnicodeDecodeError):
            pass

        try:
            with open(file_path, &#39;r&#39;) as file:
                # Try reading as CSV
                reader = csv.reader(file)
                rows = list(reader)
                if rows:
                    return &#39;csv&#39;
        except UnicodeDecodeError:
            pass

    return &#39;unknown&#39;


def pair_start_stop(starts, stops):
    paired_starts = []
    paired_stops = []
    stop_iter = iter(stops)

    try:
        current_stop = next(stop_iter)
        if current_stop is None:
            return paired_starts, paired_stops
        
        for start in starts:
            while current_stop &lt; start:
                current_stop = next(stop_iter)
            paired_starts.append(start)
            paired_stops.append(current_stop)
    except StopIteration:
        #print(&#34;Ran out of stop indexes. Last start index was:&#34;, start)
        return paired_starts, paired_stops

    return paired_starts, paired_stops


# cumulative frequencey utility used to sum a series
def cumulativeFreq(freq) -&gt; None:
    a = []
    c = []
    for i in freq:
        a.append(i + sum(c))
        c.append(i)
    return np.array(a)


# moving average utility
def movingAvg(a, threshold=300) -&gt; None:
    weights = np.repeat(1.0, threshold) / threshold
    conv = np.convolve(a, weights, &#34;valid&#34;)
    return np.append(
        conv,
        np.full(threshold - 1, conv[conv.size - 1]),
    )


def splash() -&gt; None:
   
    print(&#34;&#34;) 
    print(&#34;     _ _   _&#34;)
    print(&#34;    | | | (_)&#34;)
    print(&#34;  __| | |_ _ &#34;)
    print(&#34; / _` | __| |&#34;)
    print(&#34;| (_| | |_| |&#34;)
    print(&#34; \__,_|\__|_|&#34;)
    print(&#34;\n&#34;)          

def plot_confusion_matrix(
    cm, classes, normalize=False, title=&#34;Confusion matrix&#34;, cmap=plt.cm.Blues
):
    &#34;&#34;&#34;
    This function is from https://sklearn.org/auto_examples/model_selection/plot_confusion_matrix.html

    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    &#34;&#34;&#34;
    if normalize:
        cm = cm.astype(&#39;float&#39;) / cm.sum(axis=1)[:, np.newaxis]
    
    plt.imshow(cm, interpolation=&#34;nearest&#34;, cmap=cmap)
    plt.title(title)
    # plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes)
    plt.yticks(tick_marks, classes)

    fmt = &#34;.2f&#34; if normalize else &#34;d&#34;
    thresh = cm.max() / 2.0
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(
            j,
            i,
            format(cm[i, j], fmt),
            horizontalalignment=&#34;center&#34;,
            color=&#34;white&#34; if cm[i, j] &gt; thresh else &#34;black&#34;,
        )
    plt.ylabel(&#34;True label&#34;)
    plt.xlabel(&#34;Predicted label&#34;)
    plt.tight_layout()


## Helper for precision recall curve
def precision_recall_threshold(model, X, y, thold=0.5, title=&#34;&#34;, y_preds=None) -&gt; plt:
    try:
        if y_preds is None:
            probs_y = model.predict(X)
        else:
            probs_y = y_preds
    except:
        raise Exception(&#34;failed to get predictions during precision_recall_thrshopld call.&#34;)
    try:
        # using threshold
        probs_y[probs_y &gt; thold] = 1
        probs_y[probs_y &lt; thold] = 0
        precision, recall, thresholds = precision_recall_curve(y, probs_y)
    except:
        raise Exception(&#34;failed to create recision recall curve.&#34;)
    
    try:
        plt.title(title + &#34; Precision-Recall vs Threshold Chart&#34;)
        plt.plot(thresholds, precision[:-1], &#34;b--&#34;, label=&#34;Precision&#34;)
        plt.plot(thresholds, recall[:-1], &#34;r--&#34;, label=&#34;Recall&#34;)
        plt.ylabel(&#34;Precision, Recall&#34;)
        plt.xlabel(&#34;Threshold&#34;)
        plt.legend(loc=&#34;upper left&#34;)
        plt.ylim([0, 1])
        plt.tight_layout()
        return plt
    except:
        raise Exception(&#34;failed to plot precision recall vs threshold plt.&#34;)
    
def check_regex(pattern):
        import re
        # pattern is a string containing the regex pattern
        try:
            re.compile(pattern)
        except re.error:
            print(&#34;Non valid regex pattern - remember to not end the regex with a double backslash &#39;\\&#39;!&#34;)
            print(f&#39;---&gt; Bad pattern {pattern}&#39;)
            return False
        return True
    
def test_regex(pattern, field, dataframe):
    # check if leading/trailing forward slash is present
    if pattern[0] == &#39;/&#39; and pattern[-1] == &#39;/&#39;:
        _value = pattern[1:-1]
    else:
        _value = pattern

    # print(&#34;Regex starting with: &#34;+_value)
    if check_regex(_value):
        print(&#34;  [OK] Pattern: &#34;+_value)
        results = dataframe[field].str.contains(_value, regex=True).values
        # dataframe.loc[results]
        results_tbl = dataframe.loc[results][[field, &#39;rel&#39;]]
        print(results_tbl)

        print(f&#34;Sum of rel field: {results_tbl[&#39;rel&#39;].sum()}&#34;)
        # print(test_df[test_df[&#39;rel&#39;]&gt;0][&#39;message&#39;])
        
def analyze_model(dti_df, mod_pred_df, class_name, target_dir):
    &#34;&#34;&#34;Create false positive and false negative reports. 

    Args:
        dti_df (DataFrame): The dti file used to create feature vectors, this file is automatically generated and found in the data directory. 
        mod_pred_df (DataFrame): The prediction on test data loaded from predict output.
        class_name (str): Class name (column name).
        target_dir (str): Output directory for the reports.

    Raises:
        RuntimeError: If failed to create false positive and false negative reports.
    &#34;&#34;&#34;
    try:
        # parse model name using split of full file path
        model_name = target_dir.split(&#34;\\&#34;)[1]

        # remove class label
        dti_df.drop(class_name, axis=1, inplace=True)

        # reset index
        dti_df.reset_index()
        mod_pred_df.reset_index()

        # combine dti file with model pred
        result = pd.merge(dti_df, mod_pred_df,
                          left_index=True, right_index=True)

        # FP check
        FPOS = result.loc[(result[class_name] == 0) &amp; (result[&#39;pred&#39;] == 1)]
        FPOS.to_csv(f&#39;{target_dir}/{model_name}_false_positive_report.csv&#39;)

        # FN check
        FNEG = result.loc[(result[class_name] == 1) &amp; (result[&#39;pred&#39;] == 0)]
        FNEG.to_csv(f&#39;{target_dir}/{model_name}_false_negative_report.csv&#39;)

    except RuntimeError as e:
        raise RuntimeError(f&#34;Failed to create FP and FN reports.&#34;) from e
    

def copy_ek_rules(target_dir, rule_dir):
    try:
        # copy ek rules used to build the datasets into the model output directory
        shutil.copytree(rule_dir, target_dir+&#39;/ek_rules&#39;)

    except RuntimeError as e:
        raise RuntimeError(
            f&#34;Failed to colpy atomics to model directory.&#34;) from e

def report(dti_df, mod_pred_df, target_dir):
    try:
        # parse model name using split of full file path
        model_name = target_dir.split(&#34;\\&#34;)[1]

        # remove class label
        #dti_df.drop(class_name, axis=1, inplace=True)

        # reset index
        dti_df.reset_index()
        mod_pred_df.reset_index()

        # combine dti file with model pred
        result = pd.merge(dti_df, mod_pred_df,
                          left_index=True, right_index=True)
        # get mask from features and prediction
        mask = mod_pred_df == 1
        
        features = mask.columns.values
        for index, col in mask.items():
            mask.loc[mask[index]==True, index] = index
            mask.loc[mask[index]==False,index] = &#34;#&#34;
        mod_pred_df[&#39;tags&#39;] = mask[features].agg(&#39;,&#39;.join, axis=1)
        mod_pred_df[&#39;tags&#39;] = mod_pred_df[&#39;tags&#39;].str.replace(&#39;#,&#39;,&#39;&#39;)
        mod_pred_df[&#39;tags&#39;] = mod_pred_df[&#39;tags&#39;].str.replace(&#39;,#&#39;,&#39;&#39;)
        mod_pred_df[&#39;tags&#39;] = mod_pred_df[&#39;tags&#39;].str.replace(&#39;#&#39;,&#39;&#39;)
        
        dti_df[&#39;tags&#39;] = mod_pred_df[&#39;tags&#39;]
        dti_df[&#39;pred&#39;] = result[&#39;pred&#39;]

        dti_df.sort_values(&#39;datetime&#39;, ascending=True, inplace=True)
        
        #full report
        dti_df.to_csv(f&#39;{target_dir}/{model_name}_FULL_dti_predict_report.csv&#39;)
        
        #summary report
        dti_df = dti_df[dti_df[&#39;pred&#39;] == 1]
        summ_out = pathlib.Path(target_dir, model_name+&#34;_SUMMARY_dti_predict_report.csv&#34; )
        dti_df.to_csv(summ_out)
    
        #_data_file = pathlib.Path(self.DATA_DIR, trn_data_fn)
        #&#34;- Loaded train data: \t{str(_data_file)} ({len(self.trn_data)} rows)  &#34;
        print(f&#39;Summary report ready for review at -&gt; {str(summ_out)}&#39;)
        

        # def summary_report():
        #     if &#39;df&#39; not in st.session_state:
        #         st.session_state.df = pd.DataFrame(data=pd.read_csv(df_file))

        #     edited_df = st.data_editor(st.session_state.df, use_container_width=True, hide_index=True)

        #     edited_df.to_csv(df_file, index=False)
    
        # if st._is_running_with_streamlit:
        #     summary_report()
        # else:
        #     sys.argv = [&#34;streamlit&#34;, &#34;run&#34;, &#34;run.py&#39;]
        #     sys.exit(stcli.main())
        return summ_out

    except RuntimeError as e:
        raise RuntimeError(f&#34;Failed to create prediction report.&#34;) from e</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="app.dti.proto.Utils.analyze_model"><code class="name flex">
<span>def <span class="ident">analyze_model</span></span>(<span>dti_df, mod_pred_df, class_name, target_dir)</span>
</code></dt>
<dd>
<div class="desc"><p>Create false positive and false negative reports. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dti_df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>The dti file used to create feature vectors, this file is automatically generated and found in the data directory. </dd>
<dt><strong><code>mod_pred_df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>The prediction on test data loaded from predict output.</dd>
<dt><strong><code>class_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Class name (column name).</dd>
<dt><strong><code>target_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>Output directory for the reports.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If failed to create false positive and false negative reports.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyze_model(dti_df, mod_pred_df, class_name, target_dir):
    &#34;&#34;&#34;Create false positive and false negative reports. 

    Args:
        dti_df (DataFrame): The dti file used to create feature vectors, this file is automatically generated and found in the data directory. 
        mod_pred_df (DataFrame): The prediction on test data loaded from predict output.
        class_name (str): Class name (column name).
        target_dir (str): Output directory for the reports.

    Raises:
        RuntimeError: If failed to create false positive and false negative reports.
    &#34;&#34;&#34;
    try:
        # parse model name using split of full file path
        model_name = target_dir.split(&#34;\\&#34;)[1]

        # remove class label
        dti_df.drop(class_name, axis=1, inplace=True)

        # reset index
        dti_df.reset_index()
        mod_pred_df.reset_index()

        # combine dti file with model pred
        result = pd.merge(dti_df, mod_pred_df,
                          left_index=True, right_index=True)

        # FP check
        FPOS = result.loc[(result[class_name] == 0) &amp; (result[&#39;pred&#39;] == 1)]
        FPOS.to_csv(f&#39;{target_dir}/{model_name}_false_positive_report.csv&#39;)

        # FN check
        FNEG = result.loc[(result[class_name] == 1) &amp; (result[&#39;pred&#39;] == 0)]
        FNEG.to_csv(f&#39;{target_dir}/{model_name}_false_negative_report.csv&#39;)

    except RuntimeError as e:
        raise RuntimeError(f&#34;Failed to create FP and FN reports.&#34;) from e</code></pre>
</details>
</dd>
<dt id="app.dti.proto.Utils.check_regex"><code class="name flex">
<span>def <span class="ident">check_regex</span></span>(<span>pattern)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_regex(pattern):
        import re
        # pattern is a string containing the regex pattern
        try:
            re.compile(pattern)
        except re.error:
            print(&#34;Non valid regex pattern - remember to not end the regex with a double backslash &#39;\\&#39;!&#34;)
            print(f&#39;---&gt; Bad pattern {pattern}&#39;)
            return False
        return True</code></pre>
</details>
</dd>
<dt id="app.dti.proto.Utils.copy_ek_rules"><code class="name flex">
<span>def <span class="ident">copy_ek_rules</span></span>(<span>target_dir, rule_dir)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_ek_rules(target_dir, rule_dir):
    try:
        # copy ek rules used to build the datasets into the model output directory
        shutil.copytree(rule_dir, target_dir+&#39;/ek_rules&#39;)

    except RuntimeError as e:
        raise RuntimeError(
            f&#34;Failed to colpy atomics to model directory.&#34;) from e</code></pre>
</details>
</dd>
<dt id="app.dti.proto.Utils.cumulativeFreq"><code class="name flex">
<span>def <span class="ident">cumulativeFreq</span></span>(<span>freq) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cumulativeFreq(freq) -&gt; None:
    a = []
    c = []
    for i in freq:
        a.append(i + sum(c))
        c.append(i)
    return np.array(a)</code></pre>
</details>
</dd>
<dt id="app.dti.proto.Utils.file_type_detector"><code class="name flex">
<span>def <span class="ident">file_type_detector</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file_type_detector(file_path):
    # Check the file extension first
    if file_path.endswith(&#39;.json&#39;):
        return &#39;json&#39;
    elif file_path.endswith(&#39;.csv&#39;):
        return &#39;csv&#39;
    else:
        # If the extension is not definitive, check the content
        try:
            with open(file_path, &#39;r&#39;) as file:
                # Try parsing as JSON
                json.load(file)
                return &#39;json&#39;
        except (json.JSONDecodeError, UnicodeDecodeError):
            pass

        try:
            with open(file_path, &#39;r&#39;) as file:
                # Try reading as CSV
                reader = csv.reader(file)
                rows = list(reader)
                if rows:
                    return &#39;csv&#39;
        except UnicodeDecodeError:
            pass

    return &#39;unknown&#39;</code></pre>
</details>
</dd>
<dt id="app.dti.proto.Utils.flatten_extend"><code class="name flex">
<span>def <span class="ident">flatten_extend</span></span>(<span>matrix)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatten_extend(matrix):
    flat_list = []
    for row in matrix:
        if isinstance(row, list):
            flat_list.extend(row)
        else:
            flat_list.append(row)
    return flat_list</code></pre>
</details>
</dd>
<dt id="app.dti.proto.Utils.movingAvg"><code class="name flex">
<span>def <span class="ident">movingAvg</span></span>(<span>a, threshold=300) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def movingAvg(a, threshold=300) -&gt; None:
    weights = np.repeat(1.0, threshold) / threshold
    conv = np.convolve(a, weights, &#34;valid&#34;)
    return np.append(
        conv,
        np.full(threshold - 1, conv[conv.size - 1]),
    )</code></pre>
</details>
</dd>
<dt id="app.dti.proto.Utils.nested_dict_iter"><code class="name flex">
<span>def <span class="ident">nested_dict_iter</span></span>(<span>nested: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nested_dict_iter(nested: dict) -&gt; dict:
    for key, value in nested.items():
        if isinstance(value, abc.Mapping):
            for inner_key, inner_value in nested_dict_iter(value):
                yield inner_key, inner_value
        else:
            yield key, value</code></pre>
</details>
</dd>
<dt id="app.dti.proto.Utils.pair_start_stop"><code class="name flex">
<span>def <span class="ident">pair_start_stop</span></span>(<span>starts, stops)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pair_start_stop(starts, stops):
    paired_starts = []
    paired_stops = []
    stop_iter = iter(stops)

    try:
        current_stop = next(stop_iter)
        if current_stop is None:
            return paired_starts, paired_stops
        
        for start in starts:
            while current_stop &lt; start:
                current_stop = next(stop_iter)
            paired_starts.append(start)
            paired_stops.append(current_stop)
    except StopIteration:
        #print(&#34;Ran out of stop indexes. Last start index was:&#34;, start)
        return paired_starts, paired_stops

    return paired_starts, paired_stops</code></pre>
</details>
</dd>
<dt id="app.dti.proto.Utils.plot_confusion_matrix"><code class="name flex">
<span>def <span class="ident">plot_confusion_matrix</span></span>(<span>cm, classes, normalize=False, title='Confusion matrix', cmap=&lt;matplotlib.colors.LinearSegmentedColormap object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is from <a href="https://sklearn.org/auto_examples/model_selection/plot_confusion_matrix.html">https://sklearn.org/auto_examples/model_selection/plot_confusion_matrix.html</a></p>
<p>This function prints and plots the confusion matrix.
Normalization can be applied by setting <code>normalize=True</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_confusion_matrix(
    cm, classes, normalize=False, title=&#34;Confusion matrix&#34;, cmap=plt.cm.Blues
):
    &#34;&#34;&#34;
    This function is from https://sklearn.org/auto_examples/model_selection/plot_confusion_matrix.html

    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    &#34;&#34;&#34;
    if normalize:
        cm = cm.astype(&#39;float&#39;) / cm.sum(axis=1)[:, np.newaxis]
    
    plt.imshow(cm, interpolation=&#34;nearest&#34;, cmap=cmap)
    plt.title(title)
    # plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes)
    plt.yticks(tick_marks, classes)

    fmt = &#34;.2f&#34; if normalize else &#34;d&#34;
    thresh = cm.max() / 2.0
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(
            j,
            i,
            format(cm[i, j], fmt),
            horizontalalignment=&#34;center&#34;,
            color=&#34;white&#34; if cm[i, j] &gt; thresh else &#34;black&#34;,
        )
    plt.ylabel(&#34;True label&#34;)
    plt.xlabel(&#34;Predicted label&#34;)
    plt.tight_layout()</code></pre>
</details>
</dd>
<dt id="app.dti.proto.Utils.precision_recall_threshold"><code class="name flex">
<span>def <span class="ident">precision_recall_threshold</span></span>(<span>model, X, y, thold=0.5, title='', y_preds=None) ‑> <module 'matplotlib.pyplot' from 'C:\\Users\\codeh\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\site-packages\\matplotlib\\pyplot.py'></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def precision_recall_threshold(model, X, y, thold=0.5, title=&#34;&#34;, y_preds=None) -&gt; plt:
    try:
        if y_preds is None:
            probs_y = model.predict(X)
        else:
            probs_y = y_preds
    except:
        raise Exception(&#34;failed to get predictions during precision_recall_thrshopld call.&#34;)
    try:
        # using threshold
        probs_y[probs_y &gt; thold] = 1
        probs_y[probs_y &lt; thold] = 0
        precision, recall, thresholds = precision_recall_curve(y, probs_y)
    except:
        raise Exception(&#34;failed to create recision recall curve.&#34;)
    
    try:
        plt.title(title + &#34; Precision-Recall vs Threshold Chart&#34;)
        plt.plot(thresholds, precision[:-1], &#34;b--&#34;, label=&#34;Precision&#34;)
        plt.plot(thresholds, recall[:-1], &#34;r--&#34;, label=&#34;Recall&#34;)
        plt.ylabel(&#34;Precision, Recall&#34;)
        plt.xlabel(&#34;Threshold&#34;)
        plt.legend(loc=&#34;upper left&#34;)
        plt.ylim([0, 1])
        plt.tight_layout()
        return plt
    except:
        raise Exception(&#34;failed to plot precision recall vs threshold plt.&#34;)</code></pre>
</details>
</dd>
<dt id="app.dti.proto.Utils.report"><code class="name flex">
<span>def <span class="ident">report</span></span>(<span>dti_df, mod_pred_df, target_dir)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report(dti_df, mod_pred_df, target_dir):
    try:
        # parse model name using split of full file path
        model_name = target_dir.split(&#34;\\&#34;)[1]

        # remove class label
        #dti_df.drop(class_name, axis=1, inplace=True)

        # reset index
        dti_df.reset_index()
        mod_pred_df.reset_index()

        # combine dti file with model pred
        result = pd.merge(dti_df, mod_pred_df,
                          left_index=True, right_index=True)
        # get mask from features and prediction
        mask = mod_pred_df == 1
        
        features = mask.columns.values
        for index, col in mask.items():
            mask.loc[mask[index]==True, index] = index
            mask.loc[mask[index]==False,index] = &#34;#&#34;
        mod_pred_df[&#39;tags&#39;] = mask[features].agg(&#39;,&#39;.join, axis=1)
        mod_pred_df[&#39;tags&#39;] = mod_pred_df[&#39;tags&#39;].str.replace(&#39;#,&#39;,&#39;&#39;)
        mod_pred_df[&#39;tags&#39;] = mod_pred_df[&#39;tags&#39;].str.replace(&#39;,#&#39;,&#39;&#39;)
        mod_pred_df[&#39;tags&#39;] = mod_pred_df[&#39;tags&#39;].str.replace(&#39;#&#39;,&#39;&#39;)
        
        dti_df[&#39;tags&#39;] = mod_pred_df[&#39;tags&#39;]
        dti_df[&#39;pred&#39;] = result[&#39;pred&#39;]

        dti_df.sort_values(&#39;datetime&#39;, ascending=True, inplace=True)
        
        #full report
        dti_df.to_csv(f&#39;{target_dir}/{model_name}_FULL_dti_predict_report.csv&#39;)
        
        #summary report
        dti_df = dti_df[dti_df[&#39;pred&#39;] == 1]
        summ_out = pathlib.Path(target_dir, model_name+&#34;_SUMMARY_dti_predict_report.csv&#34; )
        dti_df.to_csv(summ_out)
    
        #_data_file = pathlib.Path(self.DATA_DIR, trn_data_fn)
        #&#34;- Loaded train data: \t{str(_data_file)} ({len(self.trn_data)} rows)  &#34;
        print(f&#39;Summary report ready for review at -&gt; {str(summ_out)}&#39;)
        

        # def summary_report():
        #     if &#39;df&#39; not in st.session_state:
        #         st.session_state.df = pd.DataFrame(data=pd.read_csv(df_file))

        #     edited_df = st.data_editor(st.session_state.df, use_container_width=True, hide_index=True)

        #     edited_df.to_csv(df_file, index=False)
    
        # if st._is_running_with_streamlit:
        #     summary_report()
        # else:
        #     sys.argv = [&#34;streamlit&#34;, &#34;run&#34;, &#34;run.py&#39;]
        #     sys.exit(stcli.main())
        return summ_out

    except RuntimeError as e:
        raise RuntimeError(f&#34;Failed to create prediction report.&#34;) from e</code></pre>
</details>
</dd>
<dt id="app.dti.proto.Utils.splash"><code class="name flex">
<span>def <span class="ident">splash</span></span>(<span>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def splash() -&gt; None:
   
    print(&#34;&#34;) 
    print(&#34;     _ _   _&#34;)
    print(&#34;    | | | (_)&#34;)
    print(&#34;  __| | |_ _ &#34;)
    print(&#34; / _` | __| |&#34;)
    print(&#34;| (_| | |_| |&#34;)
    print(&#34; \__,_|\__|_|&#34;)
    print(&#34;\n&#34;)          </code></pre>
</details>
</dd>
<dt id="app.dti.proto.Utils.test_regex"><code class="name flex">
<span>def <span class="ident">test_regex</span></span>(<span>pattern, field, dataframe)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_regex(pattern, field, dataframe):
    # check if leading/trailing forward slash is present
    if pattern[0] == &#39;/&#39; and pattern[-1] == &#39;/&#39;:
        _value = pattern[1:-1]
    else:
        _value = pattern

    # print(&#34;Regex starting with: &#34;+_value)
    if check_regex(_value):
        print(&#34;  [OK] Pattern: &#34;+_value)
        results = dataframe[field].str.contains(_value, regex=True).values
        # dataframe.loc[results]
        results_tbl = dataframe.loc[results][[field, &#39;rel&#39;]]
        print(results_tbl)

        print(f&#34;Sum of rel field: {results_tbl[&#39;rel&#39;].sum()}&#34;)
        # print(test_df[test_df[&#39;rel&#39;]&gt;0][&#39;message&#39;])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="app.dti.proto.Utils.Timer"><code class="flex name class">
<span>class <span class="ident">Timer</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Timer:
    def __enter__(self):
        self.start = time.perf_counter()
        return self

    def __exit__(self, *args):
        self.end = time.perf_counter()
        self.interval = self.end - self.start</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="app.dti.proto" href="index.html">app.dti.proto</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="app.dti.proto.Utils.analyze_model" href="#app.dti.proto.Utils.analyze_model">analyze_model</a></code></li>
<li><code><a title="app.dti.proto.Utils.check_regex" href="#app.dti.proto.Utils.check_regex">check_regex</a></code></li>
<li><code><a title="app.dti.proto.Utils.copy_ek_rules" href="#app.dti.proto.Utils.copy_ek_rules">copy_ek_rules</a></code></li>
<li><code><a title="app.dti.proto.Utils.cumulativeFreq" href="#app.dti.proto.Utils.cumulativeFreq">cumulativeFreq</a></code></li>
<li><code><a title="app.dti.proto.Utils.file_type_detector" href="#app.dti.proto.Utils.file_type_detector">file_type_detector</a></code></li>
<li><code><a title="app.dti.proto.Utils.flatten_extend" href="#app.dti.proto.Utils.flatten_extend">flatten_extend</a></code></li>
<li><code><a title="app.dti.proto.Utils.movingAvg" href="#app.dti.proto.Utils.movingAvg">movingAvg</a></code></li>
<li><code><a title="app.dti.proto.Utils.nested_dict_iter" href="#app.dti.proto.Utils.nested_dict_iter">nested_dict_iter</a></code></li>
<li><code><a title="app.dti.proto.Utils.pair_start_stop" href="#app.dti.proto.Utils.pair_start_stop">pair_start_stop</a></code></li>
<li><code><a title="app.dti.proto.Utils.plot_confusion_matrix" href="#app.dti.proto.Utils.plot_confusion_matrix">plot_confusion_matrix</a></code></li>
<li><code><a title="app.dti.proto.Utils.precision_recall_threshold" href="#app.dti.proto.Utils.precision_recall_threshold">precision_recall_threshold</a></code></li>
<li><code><a title="app.dti.proto.Utils.report" href="#app.dti.proto.Utils.report">report</a></code></li>
<li><code><a title="app.dti.proto.Utils.splash" href="#app.dti.proto.Utils.splash">splash</a></code></li>
<li><code><a title="app.dti.proto.Utils.test_regex" href="#app.dti.proto.Utils.test_regex">test_regex</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="app.dti.proto.Utils.Timer" href="#app.dti.proto.Utils.Timer">Timer</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>